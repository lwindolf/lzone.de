<html>
<head>
        <link rel="mask-icon" href="https://github.githubassets.com/assets/pinned-octocat-093da3e6fa40.svg" color="#000000">
        <link rel="alternate icon" class="js-site-favicon" type="image/png" href="https://github.githubassets.com/favicons/favicon.png">
        <link rel="icon" class="js-site-favicon" type="image/svg+xml" href="https://github.githubassets.com/favicons/favicon.svg" data-base-href="https://github.githubassets.com/favicons/favicon">
</head>
<body>
        <div>
                <a href="test">Test Link</a>
        </div>
<script>
// vim: set ts=4 sw=4:

// XPath convenience helpers

class XPath {
        static evaluate(node, expr) {
                // Workaround https://github.com/jsdom/jsdom/issues/2997
                if (!Object.getOwnPropertyDescriptor(globalThis, 'window')?.get?.toString().includes('[native code]') ?? false)
                        expr = expr.replaceAll('ns:', '')

                // Register a default resolver, otherwise we could not read Atom/RDF feeds
                let resolver = (function (element) {
                        let resolver = element.ownerDocument.createNSResolver(element);
                        let defaultNS = (new window.DOMParser).parseFromString(node.outerHTML, "text/xml").children[0].getAttribute("xmlns");

                        return function (prefix) {
                                return resolver.lookupNamespaceURI(prefix) || defaultNS;
                        };
                }(node));

                return node.ownerDocument.evaluate(
                        expr,
                        node,
                        resolver,
                        XPathResult.UNORDERED_NODE_ITERATOR_TYPE,
                        null,
                );
        }

        // Return textContent of 1st node match
        static lookupNode(node, expr) {
                const iter = XPath.evaluate(node, expr);
                return iter.iterateNext();
        }

        // Return textContent of 1st node match
        static lookup(node, expr) {
                const n = XPath.lookupNode(node, expr);
                return n ? n.textContent : undefined;
        }

        // Run callback on all matching nodes
        static foreach(node, expr, callback, data = null) {
                const iter = XPath.evaluate(node, expr);

                let n = iter.iterateNext();
                while (n) {
                        callback(n, data);
                        n = iter.iterateNext();
                }
        }
}

console.log(XPath.lookup(document.body, "//a"));

const searches = [
        { type: "MS Tile",          order: 2, xpath: "/html/head/meta[@name='msapplication-TileImage']/@href" },
        { type: "Safari Mask",      order: 3, xpath: "/html/head/link[@rel='mask-icon']/@href" },
        { type: "large icon",       order: 0, xpath: "/html/head/link[@rel='icon' or @rel='shortcut icon'][@sizes='192x192' or @sizes='144x144' or @sizes='128x128']/@href" },
        { type: "small icon",       order: 5, xpath: "/html/head/link[@rel='icon' or @rel='shortcut icon'][@sizes]/@href" },
        { type: "favicon",          order: 8, xpath: "/html/head/link[@rel='icon' or @rel='shortcut icon' or @rel='SHORTCUT ICON'][not(@sizes)]/@href" },
        { type: "Apple touch",      order: 1, xpath: "/html/head/link[@rel='apple-touch-icon' or @rel='apple-touch-icon-precomposed'][@sizes='180x180' or @sizes='152x152' or @sizes='144x144' or @sizes='120x120']/@href" },
        { type: "Apple no size",    order: 6, xpath: "/html/head/link[@rel='apple-touch-icon' or @rel='apple-touch-icon-precomposed'][not(@sizes)]/@href" },
        { type: "Apple small",      order: 7, xpath: "/html/head/link[@rel='apple-touch-icon' or @rel='apple-touch-icon-precomposed'][@sizes]/@href" }
    ];
for(s of searches) {
    console.log(s.type, XPath.lookup(document.firstChild, s.xpath));
}

</script> 
</body>
</html>